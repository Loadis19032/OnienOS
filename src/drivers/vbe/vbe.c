#include "vbe.h"
#include "../../kernel/boot/multiboot2.h"
#include "../../kernel/mm/mem.h"
#include <string.h>

extern uint32_t multiboot_magic;
extern uint32_t* multiboot_info;

#define MAX_DIRTY_REGIONS 32
#define FONT_WIDTH 8
#define FONT_HEIGHT 16

static const uint8_t font[16 * 256] = {
    // 0: Null character
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 1: Smiley face
    0x00, 0x00, 0x7E, 0x81, 0xA5, 0x81, 0x81, 0xBD, 0x99, 0x81, 0x81, 0x7E, 0x00, 0x00, 0x00, 0x00,
    
    // 2: Inverted smiley
    0x00, 0x00, 0x7E, 0xFF, 0xDB, 0xFF, 0xFF, 0xC3, 0xE7, 0xFF, 0xFF, 0x7E, 0x00, 0x00, 0x00, 0x00,
    
    // 3: Heart
    0x00, 0x00, 0x36, 0x7F, 0x7F, 0x7F, 0x3E, 0x1C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 4: Diamond
    0x00, 0x00, 0x08, 0x1C, 0x3E, 0x7F, 0x3E, 0x1C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 5: Club
    0x00, 0x00, 0x18, 0x18, 0x3C, 0x3C, 0x7E, 0x7E, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 6: Spade
    0x00, 0x00, 0x18, 0x3C, 0x7E, 0x7E, 0x7E, 0x3C, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 7: Bullet
    0x00, 0x00, 0x00, 0x00, 0x18, 0x3C, 0x3C, 0x3C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 8: Inverse bullet
    0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC3, 0xC3, 0xC3, 0xE7, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    
    // 9: Circle
    0x00, 0x00, 0x3C, 0x42, 0x81, 0x81, 0x81, 0x81, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 10: Inverse circle
    0xFF, 0xFF, 0xC3, 0xBD, 0x7E, 0x7E, 0x7E, 0x7E, 0xBD, 0xC3, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
    
    // 11: Male sign
    0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x20, 0x70, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 12: Female sign
    0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x70, 0x20, 0x70, 0x20, 0x70, 0x20, 0x00, 0x00, 0x00, 0x00,
    
    // 13: Musical note
    0x00, 0x00, 0x30, 0x30, 0x30, 0x30, 0x30, 0xFC, 0xFC, 0x78, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 14: Sun
    0x00, 0x00, 0x44, 0x28, 0x10, 0x7C, 0x10, 0x7C, 0x10, 0x28, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 15: Triangle
    0x00, 0x00, 0x10, 0x10, 0x28, 0x28, 0x44, 0x44, 0x82, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 16: Right triangle
    0x00, 0x00, 0x80, 0x40, 0x20, 0x10, 0x08, 0x10, 0x20, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 17: Left triangle
    0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 18: Up-down arrow
    0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x7C, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 19: Double exclamation
    0x00, 0x00, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 20: Paragraph
    0x00, 0x00, 0x7E, 0x92, 0x92, 0x92, 0x72, 0x12, 0x12, 0x12, 0x12, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 21: Section
    0x00, 0x00, 0x3C, 0x42, 0x40, 0x30, 0x4C, 0x42, 0x32, 0x0C, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00,
    
    // 22: Bar
    0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 23: Double bar
    0x00, 0x00, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 24: Top corner
    0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x78, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 25: Bottom corner
    0x00, 0x00, 0x7E, 0x02, 0x02, 0x02, 0x1E, 0x02, 0x02, 0x02, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 26: Right arrow
    0x00, 0x00, 0x00, 0x00, 0x08, 0x04, 0xFE, 0x04, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 27: Left arrow
    0x00, 0x00, 0x00, 0x00, 0x20, 0x40, 0xFE, 0x40, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 28: Up arrow
    0x00, 0x00, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 29: Down arrow
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 30: Right angle
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 31: Left angle
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 32: Space
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 33: !
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 34: "
    0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 35: #
    0x00, 0x00, 0x24, 0x24, 0x24, 0x7E, 0x24, 0x24, 0x7E, 0x24, 0x24, 0x24, 0x00, 0x00, 0x00, 0x00,
    
    // 36: $
    0x00, 0x00, 0x10, 0x7C, 0x92, 0x90, 0x90, 0x7C, 0x12, 0x12, 0x92, 0x7C, 0x10, 0x00, 0x00, 0x00,
    
    // 37: %
    0x00, 0x00, 0x62, 0x92, 0x94, 0x64, 0x08, 0x10, 0x26, 0x29, 0x49, 0x46, 0x00, 0x00, 0x00, 0x00,
    
    // 38: &
    0x00, 0x00, 0x38, 0x44, 0x44, 0x44, 0x38, 0x48, 0x45, 0x42, 0x45, 0x38, 0x00, 0x00, 0x00, 0x00,
    
    // 39: '
    0x00, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 40: (
    0x00, 0x00, 0x0C, 0x10, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x10, 0x0C, 0x00, 0x00, 0x00, 0x00,
    
    // 41: )
    0x00, 0x00, 0x30, 0x08, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x08, 0x30, 0x00, 0x00, 0x00, 0x00,
    
    // 42: *
    0x00, 0x00, 0x00, 0x00, 0x24, 0x18, 0x7E, 0x18, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 43: +
    0x00, 0x00, 0x00, 0x00, 0x10, 0x10, 0x10, 0xFE, 0x10, 0x10, 0x10, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 44: ,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
    
    // 45: -
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 46: .
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 47: /
    0x00, 0x00, 0x02, 0x04, 0x04, 0x08, 0x10, 0x10, 0x20, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00,
    
    // 48: 0
    0x00, 0x00, 0x3C, 0x42, 0x42, 0x46, 0x4A, 0x52, 0x62, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,
    
    // 49: 1
    0x00, 0x00, 0x08, 0x18, 0x28, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00, 0x00, 0x00,
    
    // 50: 2
    0x00, 0x00, 0x3C, 0x42, 0x42, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00,
    
    // 51: 3
    0x00, 0x00, 0x7E, 0x02, 0x04, 0x08, 0x1C, 0x02, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,
    
    // 52: 4
    0x00, 0x00, 0x04, 0x0C, 0x14, 0x24, 0x44, 0x84, 0xFE, 0x04, 0x04, 0x04, 0x00, 0x00, 0x00, 0x00,
    
    // 53: 5
    0x00, 0x00, 0x7E, 0x40, 0x40, 0x7C, 0x02, 0x02, 0x02, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,
    
    // 54: 6
    0x00, 0x00, 0x1C, 0x20, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,
    
    // 55: 7
    0x00, 0x00, 0x7E, 0x02, 0x04, 0x04, 0x08, 0x08, 0x10, 0x10, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00,
    
    // 56: 8
    0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,
    
    // 57: 9
    0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x04, 0x38, 0x00, 0x00, 0x00, 0x00,
    
    // 58: :
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 59: ;
    0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x30, 0x00, 0x00, 0x00,
    
    // 60: <
    0x00, 0x00, 0x00, 0x02, 0x04, 0x08, 0x10, 0x20, 0x10, 0x08, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00,
    
    // 61: =
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 62: >
    0x00, 0x00, 0x00, 0x40, 0x20, 0x10, 0x08, 0x04, 0x08, 0x10, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00,
    
    // 63: ?
    0x00, 0x00, 0x3C, 0x42, 0x42, 0x02, 0x04, 0x08, 0x08, 0x00, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,
    
    // 64: @
    0x00, 0x00, 0x3C, 0x42, 0x42, 0x5E, 0x52, 0x52, 0x5E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00,
    
    // 65: A
    0x00, 0x00, 0x18, 0x24, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00,
    
    // 66: B
    0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00, 0x00, 0x00,
    
    // 67: C
    0x00, 0x00, 0x3C, 0x42, 0x42, 0x40, 0x40, 0x40, 0x40, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,
    
    // 68: D
    0x00, 0x00, 0x78, 0x44, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x44, 0x78, 0x00, 0x00, 0x00, 0x00,
    
    // 69: E
    0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00,
    
    // 70: F
    0x00, 0x00, 0x7E, 0x40, 0x40, 0x40, 0x7C, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00,
    
    // 71: G
    0x00, 0x00, 0x3C, 0x42, 0x42, 0x40, 0x40, 0x4E, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,

    // 72: H
    0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x7E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00,
    
    // 73: I
    0x00, 0x00, 0x3E, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00, 0x00, 0x00,
    
    // 74: J
    0x00, 0x00, 0x1E, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x44, 0x38, 0x00, 0x00, 0x00, 0x00,

    // 75: K
    0x00, 0x00, 0x42, 0x44, 0x48, 0x50, 0x60, 0x60, 0x50, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00, 0x00,
    
    // 76: L
    0x00, 0x00, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00,
    
    // 77: M
    0x00, 0x00, 0x82, 0xC6, 0xAA, 0x92, 0x92, 0x82, 0x82, 0x82, 0x82, 0x82, 0x00, 0x00, 0x00, 0x00,

    // 78: N
    0x00, 0x00, 0x42, 0x62, 0x52, 0x52, 0x4A, 0x4A, 0x46, 0x46, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00,

    // 79: O
    0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,
    
    // 80: P
    0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00,
    
    // 81: Q
    0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x4A, 0x44, 0x3A, 0x00, 0x00, 0x00, 0x00,
    
    // 82: R
    0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x7C, 0x48, 0x44, 0x44, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00,
    
    // 83: S
    0x00, 0x00, 0x3C, 0x42, 0x42, 0x40, 0x30, 0x0C, 0x02, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,

    // 84: T
    0x00, 0x00, 0x7F, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,

        // 85: U
    0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,
    
    // 86: V
    0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00,
    
    // 87: W
    0x00, 0x00, 0x82, 0x82, 0x82, 0x82, 0x92, 0x92, 0x92, 0x92, 0x92, 0x6C, 0x00, 0x00, 0x00, 0x00,
    
    // 88: X
    0x00, 0x00, 0x42, 0x42, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00,
    
    // 89: Y
    0x00, 0x00, 0x41, 0x41, 0x22, 0x22, 0x14, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00,
    
    // 90: Z
    0x00, 0x00, 0x7E, 0x02, 0x04, 0x08, 0x10, 0x10, 0x20, 0x40, 0x40, 0x7E, 0x00, 0x00, 0x00, 0x00,
    
    // 91: [
    0x00, 0x00, 0x3C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3C, 0x00, 0x00, 0x00, 0x00,

    // 92: backslash
    0x00, 0x00, 0x80, 0x40, 0x40, 0x20, 0x10, 0x10, 0x08, 0x04, 0x04, 0x02, 0x00, 0x00, 0x00, 0x00,

    // 93: ]
    0x00, 0x00, 0x3C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x3C, 0x00, 0x00, 0x00, 0x00,
    
    // 94: ^
    0x00, 0x00, 0x08, 0x14, 0x22, 0x41, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 95: _
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x00, 0x00,

    // 96: `
    0x00, 0x00, 0x10, 0x08, 0x04, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // 97: a
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00,
    
    // 98: b
    0x00, 0x00, 0x40, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x00, 0x00, 0x00, 0x00,

    // 99: c
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x40, 0x40, 0x40, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,
    
    // 100: d
    0x00, 0x00, 0x02, 0x02, 0x02, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00,
    
    // 101: e
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x7E, 0x40, 0x40, 0x3C, 0x00, 0x00, 0x00, 0x00,

        // 102: f
    0x00, 0x00, 0x1C, 0x22, 0x20, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00,
    
    // 103: g
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00,
    
    // 104: h
    0x00, 0x00, 0x40, 0x40, 0x40, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00,
    
    // 105: i
    0x00, 0x00, 0x08, 0x08, 0x00, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00, 0x00, 0x00,
    
    // 106: j
    0x00, 0x00, 0x04, 0x04, 0x00, 0x1C, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x44, 0x44, 0x38, 0x00,
    
    // 107: k
    0x00, 0x00, 0x40, 0x40, 0x40, 0x42, 0x44, 0x48, 0x70, 0x48, 0x44, 0x42, 0x00, 0x00, 0x00, 0x00,
    
    // 108: l
    0x00, 0x00, 0x38, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x3E, 0x00, 0x00, 0x00, 0x00,

    // 109: m
    0x00, 0x00, 0x00, 0x00, 0x00, 0xFC, 0x92, 0x92, 0x92, 0x92, 0x92, 0x92, 0x00, 0x00, 0x00, 0x00,

    // 110: n
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x00, 0x00, 0x00, 0x00,
    
    // 111: o
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00,
    
    // 112: p
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7C, 0x42, 0x42, 0x42, 0x42, 0x42, 0x7C, 0x40, 0x40, 0x40, 0x00,
    
    // 113: q
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x02, 0x00,

    // 114: r
    0x00, 0x00, 0x00, 0x00, 0x00, 0x5C, 0x62, 0x40, 0x40, 0x40, 0x40, 0x40, 0x00, 0x00, 0x00, 0x00,
    
    // 115: s
    0x00, 0x00, 0x00, 0x00, 0x00, 0x3C, 0x42, 0x40, 0x30, 0x0C, 0x02, 0x42, 0x3C, 0x00, 0x00, 0x00,

        // 116: t
    0x00, 0x00, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x1C, 0x00, 0x00, 0x00, 0x00,
    
    // 117: u
    0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x00, 0x00, 0x00, 0x00,
    
    // 118: v
    0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x24, 0x24, 0x18, 0x00, 0x00, 0x00, 0x00,
    
    // 119: w
    0x00, 0x00, 0x00, 0x00, 0x00, 0x82, 0x82, 0x92, 0x92, 0x92, 0x92, 0x6C, 0x00, 0x00, 0x00, 0x00,
    
    // 120: x
    0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x00, 0x00, 0x00, 0x00,
    
    // 121: y
    0x00, 0x00, 0x00, 0x00, 0x00, 0x42, 0x42, 0x42, 0x42, 0x42, 0x42, 0x3E, 0x02, 0x02, 0x3C, 0x00,
    
    // 122: z
    0x00, 0x00, 0x00, 0x00, 0x00, 0x7E, 0x02, 0x04, 0x08, 0x10, 0x20, 0x7E, 0x00, 0x00, 0x00, 0x00,
    
    // 123: {
    0x00, 0x00, 0x0C, 0x10, 0x10, 0x10, 0x10, 0x60, 0x10, 0x10, 0x10, 0x10, 0x0C, 0x00, 0x00, 0x00,
    
    // 124: |
    0x00, 0x00, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00,
    
    // 125: }
    0x00, 0x00, 0x30, 0x08, 0x08, 0x08, 0x08, 0x06, 0x08, 0x08, 0x08, 0x08, 0x30, 0x00, 0x00, 0x00,
    
    // 126: ~
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x31, 0x4A, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,

    // 127 ...
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static uint32_t* fb = NULL;
static uint32_t* back_buffer = NULL;
static uint32_t screen_width = 1024;
static uint32_t screen_height = 768;
static uint32_t pitch = 0;
static bool vsync_enabled = false;
static uint32_t frame_count = 0;
static uint32_t current_fps = 0;
static dirty_region_t dirty_regions[MAX_DIRTY_REGIONS];
static int num_dirty_regions = 0;

static int abs(int x) { return x < 0 ? -x : x; }
static void swap(int* a, int* b) { int temp = *a; *a = *b; *b = temp; }
static int min(int a, int b) { return a < b ? a : b; }
static int max(int a, int b) { return a > b ? a : b; }

void* memcpyfast(void* restrict dest, const void* restrict src, size_t n) {
    if (n == 0) return dest;
    
    uint8_t* d = (uint8_t*)dest;
    const uint8_t* s = (const uint8_t*)src;
    
    while (n >= 64) {
        __asm__ volatile (
            "mov (%0), %%rax\n\t"
            "mov 8(%0), %%rbx\n\t"
            "mov 16(%0), %%rcx\n\t"
            "mov 24(%0), %%rdx\n\t"
            "mov 32(%0), %%rsi\n\t"
            "mov 40(%0), %%rdi\n\t"
            "mov 48(%0), %%r8\n\t"
            "mov 56(%0), %%r9\n\t"
            "mov %%rax, (%1)\n\t"
            "mov %%rbx, 8(%1)\n\t"
            "mov %%rcx, 16(%1)\n\t"
            "mov %%rdx, 24(%1)\n\t"
            "mov %%rsi, 32(%1)\n\t"
            "mov %%rdi, 40(%1)\n\t"
            "mov %%r8, 48(%1)\n\t"
            "mov %%r9, 56(%1)\n\t"
            : 
            : "r" (s), "r" (d)
            : "rax", "rbx", "rcx", "rdx", "rsi", "rdi", "r8", "r9", "memory"
        );
        s += 64;
        d += 64;
        n -= 64;
    }
    
    if (n >= 32) {
        __asm__ volatile (
            "mov (%0), %%rax\n\t"
            "mov 8(%0), %%rbx\n\t"
            "mov 16(%0), %%rcx\n\t"
            "mov 24(%0), %%rdx\n\t"
            "mov %%rax, (%1)\n\t"
            "mov %%rbx, 8(%1)\n\t"
            "mov %%rcx, 16(%1)\n\t"
            "mov %%rdx, 24(%1)\n\t"
            : 
            : "r" (s), "r" (d)
            : "rax", "rbx", "rcx", "rdx", "memory"
        );
        s += 32;
        d += 32;
        n -= 32;
    }
    
    if (n >= 16) {
        __asm__ volatile (
            "mov (%0), %%rax\n\t"
            "mov 8(%0), %%rbx\n\t"
            "mov %%rax, (%1)\n\t"
            "mov %%rbx, 8(%1)\n\t"
            : 
            : "r" (s), "r" (d)
            : "rax", "rbx", "memory"
        );
        s += 16;
        d += 16;
        n -= 16;
    }
    
    if (n >= 8) {
        __asm__ volatile (
            "mov (%0), %%rax\n\t"
            "mov %%rax, (%1)\n\t"
            : 
            : "r" (s), "r" (d)
            : "rax", "memory"
        );
        s += 8;
        d += 8;
        n -= 8;
    }

    while (n--) {
        *d++ = *s++;
    }
    
    return dest;
}

void* memsetfast(void* dest, int c, size_t n) {
    if (n == 0) return dest;
    
    uint8_t* d = (uint8_t*)dest;
    uint8_t byte = (uint8_t)c;
    uint64_t pattern = 0;
    
    for (int i = 0; i < 8; i++) {
        pattern = (pattern << 8) | byte;
    }
    
    while (n >= 64) {
        __asm__ volatile (
            "mov %1, (%0)\n\t"
            "mov %1, 8(%0)\n\t"
            "mov %1, 16(%0)\n\t"
            "mov %1, 24(%0)\n\t"
            "mov %1, 32(%0)\n\t"
            "mov %1, 40(%0)\n\t"
            "mov %1, 48(%0)\n\t"
            "mov %1, 56(%0)\n\t"
            : 
            : "r" (d), "r" (pattern)
            : "memory"
        );
        d += 64;
        n -= 64;
    }
    
    if (n >= 32) {
        __asm__ volatile (
            "mov %1, (%0)\n\t"
            "mov %1, 8(%0)\n\t"
            "mov %1, 16(%0)\n\t"
            "mov %1, 24(%0)\n\t"
            : 
            : "r" (d), "r" (pattern)
            : "memory"
        );
        d += 32;
        n -= 32;
    }
    
    if (n >= 16) {
        __asm__ volatile (
            "mov %1, (%0)\n\t"
            "mov %1, 8(%0)\n\t"
            : 
            : "r" (d), "r" (pattern)
            : "memory"
        );
        d += 16;
        n -= 16;
    }
    
    if (n >= 8) {
        __asm__ volatile (
            "mov %1, (%0)\n\t"
            : 
            : "r" (d), "r" (pattern)
            : "memory"
        );
        d += 8;
        n -= 8;
    }
    
    while (n--) {
        *d++ = byte;
    }
    
    return dest;
}

int init_lfb() {
    uint32_t* framebuffer = get_framebuffer_address(multiboot_magic, multiboot_info);
    if (!framebuffer) return -3;

    uintptr_t fb_phys = (uintptr_t)framebuffer;
    uintptr_t fb_phys_aligned = fb_phys & PAGE_MASK;
    size_t fb_size = screen_width * screen_height * sizeof(uint32_t);
    uintptr_t fb_end = fb_phys + fb_size;
    size_t page_count = (fb_end - fb_phys_aligned + PAGE_SIZE - 1) / PAGE_SIZE;
    uintptr_t fb_virt = 0xFFFF800000000000 + 0x1000000;
    
    if (map_pages(fb_virt, fb_phys_aligned, page_count, PAGE_PRESENT | PAGE_WRITABLE) != 0) {
        return -1;
    }
    
    fb = (uint32_t*)(fb_virt + (fb_phys - fb_phys_aligned));
    pitch = screen_width * sizeof(uint32_t);
    
    back_buffer = (uint32_t*)kmalloc(screen_width * screen_height * sizeof(uint32_t));
    if (!back_buffer) return -2;
    
    memsetfast(dirty_regions, 0, sizeof(dirty_regions));
    num_dirty_regions = 0;
    
    return 0;
}

uint32_t rgb(uint8_t r, uint8_t g, uint8_t b) {
    return (0xFF << 24) | (r << 16) | (g << 8) | b;
}

uint32_t rgba(uint8_t r, uint8_t g, uint8_t b, uint8_t a) {
    return (a << 24) | (r << 16) | (g << 8) | b;
}

void add_dirty_region(int x, int y, int width, int height) {
    if (num_dirty_regions >= MAX_DIRTY_REGIONS) {
        dirty_regions[0].x = 0;
        dirty_regions[0].y = 0;
        dirty_regions[0].width = screen_width;
        dirty_regions[0].height = screen_height;
        num_dirty_regions = 1;
        return;
    }

    x = max(0, x);
    y = max(0, y);
    width = min(width, screen_width - x);
    height = min(height, screen_height - y);

    for (int i = 0; i < num_dirty_regions; i++) {
        if (x >= dirty_regions[i].x && y >= dirty_regions[i].y &&
            x + width <= dirty_regions[i].x + dirty_regions[i].width &&
            y + height <= dirty_regions[i].y + dirty_regions[i].height) {
            return;
        }
    }

    dirty_regions[num_dirty_regions].x = x;
    dirty_regions[num_dirty_regions].y = y;
    dirty_regions[num_dirty_regions].width = width;
    dirty_regions[num_dirty_regions].height = height;
    num_dirty_regions++;
}

void reset_dirty_regions() {
    num_dirty_regions = 0;
}

void put_pixel(int x, int y, uint32_t color) {
    if (x < 0 || x >= screen_width || y < 0 || y >= screen_height) return;
    back_buffer[y * screen_width + x] = color;
}

void draw_char(int x, int y, char c, uint32_t color) {
    unsigned char uc = (unsigned char)c;
    const uint8_t* glyph = font + uc * FONT_HEIGHT;
    
    for (int row = 0; row < FONT_HEIGHT; row++) {
        uint8_t row_data = glyph[row];
        for (int col = 0; col < FONT_WIDTH; col++) {
            if (row_data & (1 << (7 - col))) {
                put_pixel(x + col, y + row, color);
            }
        }
    }
    add_dirty_region(x, y, FONT_WIDTH, FONT_HEIGHT);
}

void draw_string(int x, int y, const char* str, uint32_t color) {
    int start_x = x;
    while (*str) {
        if (*str == '\n') {
            y += FONT_HEIGHT;
            x = start_x;
        } else {
            draw_char(x, y, *str, color);
            x += FONT_WIDTH;
        }
        str++;
    }
}

void draw_rect(int x, int y, int width, int height, uint32_t color) {
    for (int i = x; i < x + width; i++) {
        put_pixel(i, y, color);
        put_pixel(i, y + height - 1, color);
    }
    for (int i = y; i < y + height; i++) {
        put_pixel(x, i, color);
        put_pixel(x + width - 1, i, color);
    }
    add_dirty_region(x, y, width, height);
}

void fill_rect(int x, int y, int width, int height, uint32_t color) {
    for (int j = y; j < y + height; j++) {
        for (int i = x; i < x + width; i++) {
            put_pixel(i, j, color);
        }
    }
    add_dirty_region(x, y, width, height);
}

void draw_line(int x1, int y1, int x2, int y2, uint32_t color) {
    int dx = abs(x2 - x1);
    int dy = abs(y2 - y1);
    int sx = (x1 < x2) ? 1 : -1;
    int sy = (y1 < y2) ? 1 : -1;
    int err = dx - dy;

    while (1) {
        put_pixel(x1, y1, color);
        if (x1 == x2 && y1 == y2) break;
        
        int e2 = 2 * err;
        if (e2 > -dy) {
            err -= dy;
            x1 += sx;
        }
        if (e2 < dx) {
            err += dx;
            y1 += sy;
        }
    }
    add_dirty_region(min(x1, x2), min(y1, y2), abs(x2 - x1) + 1, abs(y2 - y1) + 1);
}

void draw_triangle(int x1, int y1, int x2, int y2, int x3, int y3, uint32_t color) {
    draw_line(x1, y1, x2, y2, color);
    draw_line(x2, y2, x3, y3, color);
    draw_line(x3, y3, x1, y1, color);
}

void fill_triangle(int x1, int y1, int x2, int y2, int x3, int y3, uint32_t color) {
    if (y1 > y2) { swap(&y1, &y2); swap(&x1, &x2); }
    if (y1 > y3) { swap(&y1, &y3); swap(&x1, &x3); }
    if (y2 > y3) { swap(&y2, &y3); swap(&x2, &x3); }

    if (y1 == y3) return;

    int min_x = min(min(x1, x2), x3);
    int min_y = y1;
    int max_x = max(max(x1, x2), x3);
    int max_y = y3;

    int dy12 = y2 - y1;
    int dy13 = y3 - y1;
    int dy23 = y3 - y2;

    for (int y = y1; y <= y2; y++) {
        if (dy12 != 0 && dy13 != 0) {
            int xa = x1 + (x2 - x1) * (y - y1) / dy12;
            int xb = x1 + (x3 - x1) * (y - y1) / dy13;
            
            if (xa > xb) swap(&xa, &xb);
            
            for (int x = xa; x <= xb; x++) {
                if (x >= 0 && x < screen_width && y >= 0 && y < screen_height) {
                    back_buffer[y * screen_width + x] = color;
                }
            }
        }
    }

    for (int y = y2 + 1; y <= y3; y++) {
        if (dy23 != 0 && dy13 != 0) {
            int xa = x2 + (x3 - x2) * (y - y2) / dy23;
            int xb = x1 + (x3 - x1) * (y - y1) / dy13;
            
            if (xa > xb) swap(&xa, &xb);
            
            for (int x = xa; x <= xb; x++) {
                if (x >= 0 && x < screen_width && y >= 0 && y < screen_height) {
                    back_buffer[y * screen_width + x] = color;
                }
            }
        }
    }

    add_dirty_region(min_x, min_y, max_x - min_x + 1, max_y - min_y + 1);
}

void draw_circle(int center_x, int center_y, int radius, uint32_t color) {
    int x = 0;
    int y = radius;
    int d = 3 - 2 * radius;

    while (y >= x) {
        put_pixel(center_x + x, center_y + y, color);
        put_pixel(center_x - x, center_y + y, color);
        put_pixel(center_x + x, center_y - y, color);
        put_pixel(center_x - x, center_y - y, color);
        put_pixel(center_x + y, center_y + x, color);
        put_pixel(center_x - y, center_y + x, color);
        put_pixel(center_x + y, center_y - x, color);
        put_pixel(center_x - y, center_y - x, color);

        x++;
        if (d > 0) {
            y--;
            d = d + 4 * (x - y) + 10;
        } else {
            d = d + 4 * x + 6;
        }
    }
    add_dirty_region(center_x - radius, center_y - radius, 2 * radius, 2 * radius);
}

void fill_circle(int center_x, int center_y, int radius, uint32_t color) {
    for (int y = -radius; y <= radius; y++) {
        for (int x = -radius; x <= radius; x++) {
            if (x*x + y*y <= radius*radius) {
                put_pixel(center_x + x, center_y + y, color);
            }
        }
    }
    add_dirty_region(center_x - radius, center_y - radius, 2 * radius, 2 * radius);
}

void draw_ellipse(int center_x, int center_y, int a, int b, uint32_t color) {
    int x = 0;
    int y = b;
    int a2 = a * a;
    int b2 = b * b;
    int two_a2 = 2 * a2;
    int two_b2 = 2 * b2;
    int p;
    int px = 0;
    int py = two_a2 * y;

    p = (int)(b2 - (a2 * b) + (0.25 * a2));
    while (px < py) {
        put_pixel(center_x + x, center_y + y, color);
        put_pixel(center_x - x, center_y + y, color);
        put_pixel(center_x + x, center_y - y, color);
        put_pixel(center_x - x, center_y - y, color);

        x++;
        px += two_b2;
        if (p < 0) {
            p += b2 + px;
        } else {
            y--;
            py -= two_a2;
            p += b2 + px - py;
        }
    }

    p = (int)(b2 * (x + 0.5) * (x + 0.5) + a2 * (y - 1) * (y - 1) - a2 * b2);
    while (y >= 0) {
        put_pixel(center_x + x, center_y + y, color);
        put_pixel(center_x - x, center_y + y, color);
        put_pixel(center_x + x, center_y - y, color);
        put_pixel(center_x - x, center_y - y, color);

        y--;
        py -= two_a2;
        if (p > 0) {
            p += a2 - py;
        } else {
            x++;
            px += two_b2;
            p += a2 - py + px;
        }
    }
    add_dirty_region(center_x - a, center_y - b, 2 * a, 2 * b);
}

void fill_ellipse(int center_x, int center_y, int a, int b, uint32_t color) {
    for (int y = -b; y <= b; y++) {
        for (int x = -a; x <= a; x++) {
            if ((x*x * b*b + y*y * a*a) <= a*a * b*b) {
                put_pixel(center_x + x, center_y + y, color);
            }
        }
    }
    add_dirty_region(center_x - a, center_y - b, 2 * a, 2 * b);
}

void draw_rounded_rect(int x, int y, int width, int height, int radius, uint32_t color) {
    draw_circle(x + radius, y + radius, radius, color);
    draw_circle(x + width - radius - 1, y + radius, radius, color);
    draw_circle(x + radius, y + height - radius - 1, radius, color);
    draw_circle(x + width - radius - 1, y + height - radius - 1, radius, color);

    draw_line(x + radius, y, x + width - radius, y, color);
    draw_line(x + radius, y + height - 1, x + width - radius, y + height - 1, color);
    draw_line(x, y + radius, x, y + height - radius, color);
    draw_line(x + width - 1, y + radius, x + width - 1, y + height - radius, color);
}

void fill_rounded_rect(int x, int y, int width, int height, int radius, uint32_t color) {
    fill_rect(x + radius, y, width - 2 * radius, height, color);
    fill_rect(x, y + radius, radius, height - 2 * radius, color);
    fill_rect(x + width - radius, y + radius, radius, height - 2 * radius, color);
    fill_circle(x + radius, y + radius, radius, color);
    fill_circle(x + width - radius - 1, y + radius, radius, color);
    fill_circle(x + radius, y + height - radius - 1, radius, color);
    fill_circle(x + width - radius - 1, y + height - radius - 1, radius, color);
}

void draw_polygon(const int* points, int num_points, uint32_t color) {
    for (int i = 0; i < num_points; i++) {
        int next = (i + 1) % num_points;
        draw_line(points[i*2], points[i*2+1], points[next*2], points[next*2+1], color);
    }
}

void fill_polygon(const int* points, int num_points, uint32_t color) {
    int min_y = points[1], max_y = points[1];
    for (int i = 0; i < num_points; i++) {
        if (points[i*2+1] < min_y) min_y = points[i*2+1];
        if (points[i*2+1] > max_y) max_y = points[i*2+1];
    }

    int intersections[32];
    int intersection_count;

    for (int y = min_y; y <= max_y; y++) {
        intersection_count = 0;
        
        for (int i = 0; i < num_points; i++) {
            int j = (i + 1) % num_points;
            int x1 = points[i*2], y1 = points[i*2+1];
            int x2 = points[j*2], y2 = points[j*2+1];

            if ((y1 <= y && y2 > y) || (y2 <= y && y1 > y)) {
                int x = x1 + (x2 - x1) * (y - y1) / (y2 - y1);
                intersections[intersection_count++] = x;
            }
        }

        for (int i = 0; i < intersection_count - 1; i++) {
            for (int j = 0; j < intersection_count - i - 1; j++) {
                if (intersections[j] > intersections[j + 1]) {
                    swap(&intersections[j], &intersections[j + 1]);
                }
            }
        }

        for (int i = 0; i < intersection_count; i += 2) {
            if (i + 1 < intersection_count) {
                draw_line(intersections[i], y, intersections[i + 1], y, color);
            }
        }
    }
}

void swap_buffers() {
    for (int i = 0; i < num_dirty_regions; i++) {
        dirty_region_t dr = dirty_regions[i];
        for (int y = dr.y; y < dr.y + dr.height; y++) {
            uint32_t* src = back_buffer + y * screen_width + dr.x;
            uint32_t* dst = fb + y * screen_width + dr.x;
            memcpyfast(dst, src, dr.width * sizeof(uint32_t));
        }
    }
    
    reset_dirty_regions();
    
    if (vsync_enabled) {
    }
}

void clear_screen(uint32_t color) {
    for (uint32_t i = 0; i < screen_width * screen_height; i++) {
        back_buffer[i] = color;
    }
    add_dirty_region(0, 0, screen_width, screen_height);
}

uint32_t get_screen_width() { return screen_width; }
uint32_t get_screen_height() { return screen_height; }
uint32_t* get_framebuffer() { return back_buffer; }
void enable_vsync() { vsync_enabled = true; }
void disable_vsync() { vsync_enabled = false; }